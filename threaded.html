<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>NestJS: Đơn luồng vs Đa luồng (Visualizer)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121832; --panel2:#0f1530;
      --text:#e6ebff; --muted:#a9b3d1; --accent:#7aa2ff; --ok:#3ddc97; --warn:#ffd166; --err:#ff6b6b;
      --chip:#1b2347; --chip-border:#2a376b; --shadow:0 10px 30px rgba(0,0,0,.35); --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 80% -10%, #1a245a 0%, #0b1020 50%, #0b1020 100%), var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{text-align:center;padding:18px 12px 6px}
    h1{font-size:clamp(18px,4vw,28px);margin:0 0 6px}
    .subtitle{color:var(--muted);font-size:clamp(12px,2.5vw,14px)}
    .wrap{max-width:1200px;margin:0 auto;padding:12px;display:grid;gap:12px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.12);border-radius:12px;box-shadow:var(--shadow)}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:10px}
    .btn{background:var(--accent);color:#0b1020;border:0;border-radius:10px;padding:10px 12px;font-weight:700;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .chip{background:var(--chip);border:1px solid var(--chip-border);color:var(--text);padding:8px 10px;border-radius:10px;font-size:12px;display:flex;gap:8px;align-items:center}
    .chip input{accent-color:var(--accent)}
    .grid{display:grid;gap:10px}
    .lanes{display:grid;gap:10px;padding:12px}
    .lane{display:grid;grid-template-columns: 150px 1fr;gap:10px}
    .lane-name{color:var(--muted);font-size:12px;padding-top:6px}
    .flow{display:flex;gap:10px;overflow-x:auto;padding-bottom:6px;scroll-snap-type:x proximity}
    .flow::-webkit-scrollbar{height:10px}
    .flow::-webkit-scrollbar-thumb{background:rgba(255,255,255,.15);border-radius:10px}
    .card{min-width:220px;background:linear-gradient(180deg,rgba(20,26,60,.9),rgba(14,20,45,.9));border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;scroll-snap-align:start;position:relative}
    .title{font-weight:700;font-size:13px;margin-bottom:6px}
    .desc{font-size:12px;color:var(--muted);line-height:1.45}
    .badge{position:absolute;top:8px;right:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);padding:2px 6px;font-size:10px;border-radius:999px;color:var(--muted)}
    .log{padding:10px;max-height:220px;overflow:auto;background:var(--panel2);font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;border-top:1px solid rgba(255,255,255,.12)}
    .explain{padding:12px;display:grid;gap:10px}
    .ex{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:12px}
    .ex h3{margin:0 0 6px;font-size:14px}
    .ex p{margin:0;color:var(--muted);font-size:13px;line-height:1.55}
    .pill{display:inline-block;font-size:11px;border:1px solid rgba(255,255,255,.2);border-radius:999px;padding:2px 6px;margin-right:6px}
    @media (max-width:800px){.lane{grid-template-columns:1fr}.card{min-width:240px}}
  </style>
</head>
<body>
  <header>
    <h1>NestJS: Đơn luồng vs Đa luồng</h1>
    <div class="subtitle">Main JS thread đơn luồng + libuv I/O, ThreadPool, Worker Threads, Cluster/Fork và thông điệp giữa chúng</div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="controls">
        <button id="run" class="btn">Run Demo</button>
        <button id="clear" class="btn" style="background:#3ddc97;color:#07121f">Clear Log</button>
        <label class="chip"><input id="opt-io" type="checkbox" checked/> I/O-bound (non-blocking)</label>
        <label class="chip"><input id="opt-cpu" type="checkbox" checked/> CPU-bound (nặng)</label>
        <label class="chip"><input id="opt-workers" type="checkbox" checked/> Dùng Worker Threads</label>
        <label class="chip"><input id="opt-cluster" type="checkbox" checked/> Dùng Cluster (đa tiến trình)</label>
      </div>

      <div class="lanes">
        <div class="lane">
          <div class="lane-name">Main Thread (JS)</div>
          <div class="flow">
            <div class="card">
              <div class="title">Event Loop</div>
              <div class="desc">Thực thi handler Nest. I/O chờ ở libuv. CPU sync sẽ block.</div>
              <div class="badge">single</div>
            </div>
            <div class="card">
              <div class="title">Interceptors/Guards/Pipes</div>
              <div class="desc">Chạy trong main thread. Tránh công việc đồng bộ nặng ở đây.</div>
            </div>
          </div>
        </div>

        <div class="lane">
          <div class="lane-name">libuv Thread Pool</div>
          <div class="flow">
            <div class="card">
              <div class="title">fs/crypto/zlib/dns</div>
              <div class="desc">Tác vụ offload sang pool → callback trả về main thread khi hoàn tất.</div>
              <div class="badge">pool</div>
            </div>
            <div class="card">
              <div class="title">UV_THREADPOOL_SIZE</div>
              <div class="desc">Mặc định 4. Tăng khi nhiều tác vụ CPU-ish trong pool, đo đạc trước khi chỉnh.</div>
            </div>
          </div>
        </div>

        <div class="lane">
          <div class="lane-name">Worker Threads</div>
          <div class="flow">
            <div class="card">
              <div class="title">Isolates V8 riêng</div>
              <div class="desc">Dùng cho CPU-bound: ảnh, crypto, ML CPU. Giao tiếp message/transferable/SharedArrayBuffer.</div>
              <div class="badge">workers</div>
            </div>
            <div class="card">
              <div class="title">Worker Pool pattern</div>
              <div class="desc">Giới hạn số worker, hàng đợi job, timeout, backpressure.</div>
            </div>
          </div>
        </div>

        <div class="lane">
          <div class="lane-name">Cluster/Processes</div>
          <div class="flow">
            <div class="card">
              <div class="title">Cluster/PM2</div>
              <div class="desc">Nhiều process Nest chia sẻ cổng. Mỗi process có event loop riêng.</div>
              <div class="badge">cluster</div>
            </div>
            <div class="card">
              <div class="title">IPC/Queues</div>
              <div class="desc">Giao tiếp qua IPC/Redis/Kafka/BullMQ. Tách fail domain, scale ngang.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="log" class="log panel" aria-live="polite"></div>
    </div>

    <div class="panel explain">
      <div class="ex">
        <h3>Tư duy “đơn luồng” trong Nest</h3>
        <p>
          - Mọi JS chạy trên 1 event loop. Hãy giữ handler mảnh và async.<br/>
          - I/O non-blocking giúp scale tốt; CPU sync sẽ “đóng băng” tất cả route trên process hiện tại.
        </p>
      </div>
      <div class="ex">
        <h3>Khi nào “đa luồng” có ích?</h3>
        <p>
          - Thread pool: tăng throughput cho API Node có hỗ trợ (fs, crypto, zlib).<br/>
          - Worker threads: offload CPU-bound để không chặn loop, đạt song song thực.<br/>
          - Cluster: tận dụng đa core cho I/O-bound, cô lập lỗi, scale ngang.
        </p>
      </div>
      <div class="ex">
        <h3>Mẫu triển khai trong Nest</h3>
        <p>
          - Cluster bootstrap (PM2 cluster) + Redis adapter cho WebSocket sticky.<br/>
          - WorkerPoolService quản lý pool workers (round-robin/least-busy) + backpressure.<br/>
          - Queue (BullMQ) để decouple; consumers có thể chạy ở process khác.
        </p>
      </div>
      <div class="ex">
        <h3>Bảo trì & đo đạc</h3>
        <p>
          - Theo dõi event loop lag, CPU usage, pool saturation; profiling p95/p99 latency.<br/>
          - Graceful shutdown: drain queue, terminate workers, đóng kết nối DB sạch sẽ.
        </p>
      </div>
    </div>
  </div>

  <script>
    const logEl = document.getElementById('log');
    const btnRun = document.getElementById('run');
    const btnClear = document.getElementById('clear');
    const optIO = document.getElementById('opt-io');
    const optCPU = document.getElementById('opt-cpu');
    const optWorkers = document.getElementById('opt-workers');
    const optCluster = document.getElementById('opt-cluster');

    function log(msg){
      const t = new Date().toLocaleTimeString();
      logEl.textContent += `[${t}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    btnClear.addEventListener('click', ()=> logEl.textContent = '');

    // Mô phỏng tương đối: setTimeout ~ I/O, “CPU-bound” dùng busy loop nhỏ (có throttle) để minh họa blocking,
    // “Worker threads” & “Cluster” mô phỏng bằng chạy song song qua Web Workers giả lập bằng setTimeout phân mảnh (không có API Node trong trình duyệt).
    function cpuHeavySim(label, durationMs){
      const start = performance.now();
      // Chunked busy work để không khóa tab quá lâu (mô phỏng blocking).
      function chunk(){
        let x = 0;
        // làm việc ~2ms mỗi chunk
        const end = performance.now() + 2;
        while(performance.now() < end){ x += Math.sqrt(Math.random()); }
        if(performance.now() - start < durationMs){
          // nếu “single thread”: tiếp tục ngay (blocking cảm giác cao)
          // nếu “worker/cluster”: sẽ tách ra thành setTimeout để mô phỏng song song
          setTimeout(chunk, 0);
        }else{
          log(`${label} done (CPU ~${Math.round(durationMs)}ms simulated)`);
        }
      }
      chunk();
    }

    function cpuHeavyParallel(label, durationMs, parts){
      let done = 0;
      for(let i=0;i<parts;i++){
        setTimeout(()=>{
          const subLabel = `${label}-part${i+1}`;
          cpuHeavySim(subLabel, durationMs/parts);
          // Đánh dấu hoàn thành từng phần sau 1 độ trễ nữa
          setTimeout(()=>{
            done++;
            if(done===parts) log(`${label} aggregated result from ${parts} parts`);
          }, durationMs/parts + 5);
        }, 0);
      }
    }

    function runDemo(){
      btnRun.disabled = true;
      log('--- Start Demo: Single vs Multi concepts (simulated) ---');

      // I/O-bound
      if(optIO.checked){
        log('I/O-bound: start non-blocking db/file call (sim)');
        setTimeout(()=> log('I/O-bound: callback fired (main thread free while waiting)'), 20);
      }

      // CPU-bound in single thread
      if(optCPU.checked){
        log('CPU-bound: heavy compute on main thread (will contend with event loop)');
        cpuHeavySim('CPU-single', 60);
      }

      // Worker Threads (simulated with partitioned tasks)
      if(optWorkers.checked){
        log('Workers: offload CPU job in parallel parts (simulated partition)');
        cpuHeavyParallel('CPU-workers', 80, 4);
      }

      // Cluster: multiple processes (simulate by duplicating timelines)
      if(optCluster.checked){
        log('Cluster: two process handling different requests (simulated concurrency)');
        setTimeout(()=> log('Cluster-P1 handled request A (I/O)'), 15);
        setTimeout(()=> log('Cluster-P2 handled request B (CPU small)'), 10);
        setTimeout(()=> log('Cluster-P2 finished CPU small'), 25);
      }

      setTimeout(()=>{
        log('--- End Demo ---');
        btnRun.disabled = false;
      }, 300);
    }

    btnRun.addEventListener('click', runDemo);
  </script>
</body>
</html>